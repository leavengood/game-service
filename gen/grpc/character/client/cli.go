// Code generated by goa v3.12.4, DO NOT EDIT.
//
// character gRPC client CLI support package
//
// Command:
// $ goa gen game-service/design

package client

import (
	"encoding/json"
	"fmt"
	character "game-service/gen/character"
	characterpb "game-service/gen/grpc/character/pb"

	goa "goa.design/goa/v3/pkg"
)

// BuildShowPayload builds the payload for the character show endpoint from CLI
// flags.
func BuildShowPayload(characterShowMessage string, characterShowView string) (*character.ShowPayload, error) {
	var err error
	var message characterpb.ShowRequest
	{
		if characterShowMessage != "" {
			err = json.Unmarshal([]byte(characterShowMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Tempore qui dignissimos quia.\"\n   }'")
			}
		}
	}
	var view *string
	{
		if characterShowView != "" {
			view = &characterShowView
			if !(*view == "default" || *view == "tiny") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("view", *view, []any{"default", "tiny"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	v := &character.ShowPayload{
		ID: message.Id,
	}
	v.View = view

	return v, nil
}

// BuildAddPayload builds the payload for the character add endpoint from CLI
// flags.
func BuildAddPayload(characterAddMessage string) (*character.Character, error) {
	var err error
	var message characterpb.AddRequest
	{
		if characterAddMessage != "" {
			err = json.Unmarshal([]byte(characterAddMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"A grizzled wizard with a penchant for mayhem and mead\",\n      \"experience\": 10767,\n      \"health\": 946,\n      \"name\": \"Arvish the Wise\"\n   }'")
			}
		}
	}
	v := &character.Character{
		Name:        message.Name,
		Description: message.Description,
		Health:      message.Health,
		Experience:  message.Experience,
	}

	return v, nil
}

// BuildUpdatePayload builds the payload for the character update endpoint from
// CLI flags.
func BuildUpdatePayload(characterUpdateMessage string) (*character.UpdatePayload, error) {
	var err error
	var message characterpb.UpdateRequest
	{
		if characterUpdateMessage != "" {
			err = json.Unmarshal([]byte(characterUpdateMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"character\": {\n         \"description\": \"A grizzled wizard with a penchant for mayhem and mead\",\n         \"experience\": 13813,\n         \"health\": 35,\n         \"name\": \"Arvish the Wise\"\n      },\n      \"id\": \"Fugit ipsa debitis dolor ipsam.\"\n   }'")
			}
		}
	}
	v := &character.UpdatePayload{
		ID: message.Id,
	}
	if message.Character != nil {
		v.Character = protobufCharacterpbCharacter2ToCharacterCharacter(message.Character)
	}

	return v, nil
}

// BuildRemovePayload builds the payload for the character remove endpoint from
// CLI flags.
func BuildRemovePayload(characterRemoveMessage string) (*character.RemovePayload, error) {
	var err error
	var message characterpb.RemoveRequest
	{
		if characterRemoveMessage != "" {
			err = json.Unmarshal([]byte(characterRemoveMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Veritatis et.\"\n   }'")
			}
		}
	}
	v := &character.RemovePayload{
		ID: message.Id,
	}

	return v, nil
}
